/**
 * User.js
 *
 * @description :: User model, unique by email
 */
var crypto    = require('crypto');
var exportUtils = require('../services/utils/export');
var Promise = require('bluebird');
var validator = require('validator');

module.exports = {
  schema: true,
  tableName: 'midas_user',
  attributes: {
    username: { type: 'email', unique: true },
    passports: { collection: 'Passport', via: 'user' },
    badges: { collection: 'badge', via: 'user'},

    // Core attributes that appear in the user's profile
    name: 'STRING',    // Identifies people on the site
    title: 'STRING',   // Professional Title
    bio: 'STRING',     // Biography

    // User's profile photo
    // If photoId is not null, the URL to the file is /file/get/:id
    photoId: 'INTEGER',
    // If photoUrl is not null, then an external provider gave us the photo
    // Use the URL directly as the resource identifier for the photo.
    photoUrl: 'STRING',

    // User metadata for service delivery
    isAdmin: {
      type: 'BOOLEAN',
      defaultsTo: false
    },

    // User is an admin for their agency
    isAgencyAdmin: {
      type: 'BOOLEAN',
      defaultsTo: false
    },

    // is the user's login disabled
    disabled: {
      type: 'BOOLEAN',
      defaultsTo: false
    },

    // Store the number of invalid password attempts
    passwordAttempts: {
      type: 'INTEGER',
      defaultsTo: 0
    },

    // Store the number of completedTasks
    completedTasks: {
      type: 'INTEGER',
      defaultsTo: 0
    },

    // Tag association
    tags: {
      collection: 'tagEntity',
      via: 'users',
      dominant: true
    },

    /**
     * Increment the task counter by one and
     * check to see if a badge should be awarded
     *
     * @param { Task } task
     * @param { Object } opts
     */
    taskCompleted: function ( task, opts ) {
      var user = this;
      opts = opts || {};
      user.completedTasks += 1;
      this.save( function ( err, u ) {
        if ( err ) { return sails.log.error( err ); }
        Badge.awardForTaskCompletion( task, user, opts );
      } );
    },

    toJSON: function() {
      var obj = this.toObject();
      delete obj.passports;
      return obj;
    },
  },
  forgotPassword: function(email) {
    sails.log.verbose('User.forgotPassword', email);
    email = email.toLowerCase().trim();
    if (validator.isEmail(email) !== true) {
      sails.log.verbose('invalid email');
      return Promise.reject('Please enter a valid email address.');
      //throw new Error('Please enter a valid email address.');
    }
    var promise = User.findOneByUsername(email)
    .then(function(user) {
      sails.log.verbose('User.forgotPassword found user:', user);

      // if there's no matching email address, don't provide the user feedback.
      // make it look like success
      if (!user) return {};

      var token = {
        userId: user.id
        // token is auto-generated by the model
      };
      return UserPasswordReset.create(token);
    });
    return promise;
  },
  beforeValidate: function(values, done) {
    if ( values && values.username ) {
      values.username = values.username.toLowerCase();
    }
    done();
  },

  beforeCreate: function(values, done) {
    // If configured, validate that user has an email from a valid domain
    if (sails.config.validateDomains && sails.config.domains) {
      var domains = sails.config.domains.map(function(domain) {
            return new RegExp(domain.replace(/\./g, '\.') + '$');
          });
      if (!_.find(domains, function(domain) {
        return domain.test(values.username.split('@')[1]);
      })) return done('invalid domain');
    }
    done();
  },

  // Note: this can be used to create admin users
  // relies on filtering in controller actions for safety
  register: function(attributes, done) {
    if (!attributes.password || attributes.password === '') {
      return done(new Error('password may not be blank'));
    }
    User.create(attributes, function (err, user) {
      if (err) {
        // used to set req.flash: Error.Passport.User.Exists
        sails.log.verbose('register: failed to create user ', attributes.username);
        return done(err);
      }
      // Generating accessToken for API authentication
      var token = crypto.randomBytes(48).toString('base64');

      Passport.create({
        protocol    : 'local'
      , password    : attributes.password
      , user        : user.id
      , accessToken : token
      }, function (err, passport) {
        if (err) {
          // used to set req.flash: Error.Passport.Password.Invalid
          sails.log.verbose('register: failed to create passport for user ', user.id);
          return user.destroy(function (destroyErr) {
            done(destroyErr || err);
          });
        }

        Notification.create({
          action: 'user.create.welcome',
          model: user
        }, function(err, notification) {
          if (err) return done(err);
          return done(null, user);
        });

      });
    });

  },

  // returns a promise
  findByDomain: function(domain) {
    var queryStr = "SELECT * FROM midas_user WHERE username SIMILAR TO '%(@|.)" +
                   domain + "'";
    var userQuery = Promise.promisify(User.query, {context: User});
    return userQuery(queryStr).
    then(function(result) {
      return result.rows;
    })
  },

  // TODO: add more fields, likely driven off subqueries
  exportFormat: {
    'user_id': 'id',
    'name': {field: 'name', filter: exportUtils.nullToEmptyString},
    'username': {field: 'username', filter: exportUtils.nullToEmptyString},
    'title': {field: 'title', filter: exportUtils.nullToEmptyString},

    // The two below fields are not directly on the user model
    // They are populated from tags by UserController.export
    'agency': {field: 'agency', filter: exportUtils.nullToEmptyString},
    'location': {field: 'location', filter: exportUtils.nullToEmptyString},

    'bio': {field: 'bio', filter: exportUtils.nullToEmptyString},
    'admin': 'isAdmin',
    'disabled': 'disabled'
  },

};
